# coding: utf-8

"""
    Paheko API

    Documentation Swagger pour l'API de Paheko  # noqa: E501

    OpenAPI spec version: 1.0.0
    
    Generated by: https://github.com/paheko-api/paheko-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from paheko_client.api_client import ApiClient


class DefaultApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/paheko-api/paheko-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def accounting_account_get(self, **kwargs):  # noqa: E501
        """Récupérer tous les comptes comptables  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.accounting_account_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.accounting_account_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.accounting_account_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def accounting_account_get_with_http_info(self, **kwargs):  # noqa: E501
        """Récupérer tous les comptes comptables  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.accounting_account_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method accounting_account_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/accounting/account', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def accounting_category_get(self, **kwargs):  # noqa: E501
        """Récupérer toutes les catégories comptables  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.accounting_category_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.accounting_category_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.accounting_category_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def accounting_category_get_with_http_info(self, **kwargs):  # noqa: E501
        """Récupérer toutes les catégories comptables  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.accounting_category_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method accounting_category_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/accounting/category', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def accounting_charts_get(self, **kwargs):  # noqa: E501
        """Récupérer les plans comptables  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.accounting_charts_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.accounting_charts_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.accounting_charts_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def accounting_charts_get_with_http_info(self, **kwargs):  # noqa: E501
        """Récupérer les plans comptables  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.accounting_charts_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method accounting_charts_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/accounting/charts', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def accounting_charts_idchart_accounts_get(self, id_chart, **kwargs):  # noqa: E501
        """Récupérer les comptes d'un plan comptable  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.accounting_charts_idchart_accounts_get(id_chart, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id_chart: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.accounting_charts_idchart_accounts_get_with_http_info(id_chart, **kwargs)  # noqa: E501
        else:
            (data) = self.accounting_charts_idchart_accounts_get_with_http_info(id_chart, **kwargs)  # noqa: E501
            return data

    def accounting_charts_idchart_accounts_get_with_http_info(self, id_chart, **kwargs):  # noqa: E501
        """Récupérer les comptes d'un plan comptable  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.accounting_charts_idchart_accounts_get_with_http_info(id_chart, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id_chart: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id_chart']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method accounting_charts_idchart_accounts_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id_chart' is set
        if ('id_chart' not in params or
                params['id_chart'] is None):
            raise ValueError("Missing the required parameter `id_chart` when calling `accounting_charts_idchart_accounts_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_chart' in params:
            path_params['ID_CHART'] = params['id_chart']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/accounting/charts/{ID_CHART}/accounts', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def accounting_transaction_idtransaction_delete(self, id_transaction, **kwargs):  # noqa: E501
        """Supprimer une transaction  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.accounting_transaction_idtransaction_delete(id_transaction, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id_transaction: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.accounting_transaction_idtransaction_delete_with_http_info(id_transaction, **kwargs)  # noqa: E501
        else:
            (data) = self.accounting_transaction_idtransaction_delete_with_http_info(id_transaction, **kwargs)  # noqa: E501
            return data

    def accounting_transaction_idtransaction_delete_with_http_info(self, id_transaction, **kwargs):  # noqa: E501
        """Supprimer une transaction  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.accounting_transaction_idtransaction_delete_with_http_info(id_transaction, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id_transaction: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id_transaction']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method accounting_transaction_idtransaction_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id_transaction' is set
        if ('id_transaction' not in params or
                params['id_transaction'] is None):
            raise ValueError("Missing the required parameter `id_transaction` when calling `accounting_transaction_idtransaction_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_transaction' in params:
            path_params['ID_TRANSACTION'] = params['id_transaction']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/accounting/transaction/{ID_TRANSACTION}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def accounting_transaction_idtransaction_get(self, id_transaction, **kwargs):  # noqa: E501
        """Récupérer une transaction  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.accounting_transaction_idtransaction_get(id_transaction, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id_transaction: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.accounting_transaction_idtransaction_get_with_http_info(id_transaction, **kwargs)  # noqa: E501
        else:
            (data) = self.accounting_transaction_idtransaction_get_with_http_info(id_transaction, **kwargs)  # noqa: E501
            return data

    def accounting_transaction_idtransaction_get_with_http_info(self, id_transaction, **kwargs):  # noqa: E501
        """Récupérer une transaction  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.accounting_transaction_idtransaction_get_with_http_info(id_transaction, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id_transaction: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id_transaction']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method accounting_transaction_idtransaction_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id_transaction' is set
        if ('id_transaction' not in params or
                params['id_transaction'] is None):
            raise ValueError("Missing the required parameter `id_transaction` when calling `accounting_transaction_idtransaction_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_transaction' in params:
            path_params['ID_TRANSACTION'] = params['id_transaction']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/accounting/transaction/{ID_TRANSACTION}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def accounting_transaction_idtransaction_post(self, id_transaction, **kwargs):  # noqa: E501
        """Modifier une transaction  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.accounting_transaction_idtransaction_post(id_transaction, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id_transaction: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.accounting_transaction_idtransaction_post_with_http_info(id_transaction, **kwargs)  # noqa: E501
        else:
            (data) = self.accounting_transaction_idtransaction_post_with_http_info(id_transaction, **kwargs)  # noqa: E501
            return data

    def accounting_transaction_idtransaction_post_with_http_info(self, id_transaction, **kwargs):  # noqa: E501
        """Modifier une transaction  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.accounting_transaction_idtransaction_post_with_http_info(id_transaction, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id_transaction: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id_transaction']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method accounting_transaction_idtransaction_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id_transaction' is set
        if ('id_transaction' not in params or
                params['id_transaction'] is None):
            raise ValueError("Missing the required parameter `id_transaction` when calling `accounting_transaction_idtransaction_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_transaction' in params:
            path_params['ID_TRANSACTION'] = params['id_transaction']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/accounting/transaction/{ID_TRANSACTION}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def accounting_transaction_idtransaction_put(self, id_transaction, **kwargs):  # noqa: E501
        """Mettre à jour une transaction  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.accounting_transaction_idtransaction_put(id_transaction, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id_transaction: (required)
        :param str label:
        :param float amount:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.accounting_transaction_idtransaction_put_with_http_info(id_transaction, **kwargs)  # noqa: E501
        else:
            (data) = self.accounting_transaction_idtransaction_put_with_http_info(id_transaction, **kwargs)  # noqa: E501
            return data

    def accounting_transaction_idtransaction_put_with_http_info(self, id_transaction, **kwargs):  # noqa: E501
        """Mettre à jour une transaction  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.accounting_transaction_idtransaction_put_with_http_info(id_transaction, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id_transaction: (required)
        :param str label:
        :param float amount:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id_transaction', 'label', 'amount']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method accounting_transaction_idtransaction_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id_transaction' is set
        if ('id_transaction' not in params or
                params['id_transaction'] is None):
            raise ValueError("Missing the required parameter `id_transaction` when calling `accounting_transaction_idtransaction_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_transaction' in params:
            path_params['ID_TRANSACTION'] = params['id_transaction']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'label' in params:
            form_params.append(('label', params['label']))  # noqa: E501
        if 'amount' in params:
            form_params.append(('amount', params['amount']))  # noqa: E501

        body_params = None
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/accounting/transaction/{ID_TRANSACTION}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def accounting_transaction_idtransaction_subscriptions_delete(self, id_transaction, **kwargs):  # noqa: E501
        """Dissocier des inscriptions d'une écriture  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.accounting_transaction_idtransaction_subscriptions_delete(id_transaction, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id_transaction: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.accounting_transaction_idtransaction_subscriptions_delete_with_http_info(id_transaction, **kwargs)  # noqa: E501
        else:
            (data) = self.accounting_transaction_idtransaction_subscriptions_delete_with_http_info(id_transaction, **kwargs)  # noqa: E501
            return data

    def accounting_transaction_idtransaction_subscriptions_delete_with_http_info(self, id_transaction, **kwargs):  # noqa: E501
        """Dissocier des inscriptions d'une écriture  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.accounting_transaction_idtransaction_subscriptions_delete_with_http_info(id_transaction, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id_transaction: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id_transaction']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method accounting_transaction_idtransaction_subscriptions_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id_transaction' is set
        if ('id_transaction' not in params or
                params['id_transaction'] is None):
            raise ValueError("Missing the required parameter `id_transaction` when calling `accounting_transaction_idtransaction_subscriptions_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_transaction' in params:
            path_params['ID_TRANSACTION'] = params['id_transaction']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/accounting/transaction/{ID_TRANSACTION}/subscriptions', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def accounting_transaction_idtransaction_subscriptions_get(self, id_transaction, **kwargs):  # noqa: E501
        """Récupérer les inscriptions liées à une écriture  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.accounting_transaction_idtransaction_subscriptions_get(id_transaction, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id_transaction: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.accounting_transaction_idtransaction_subscriptions_get_with_http_info(id_transaction, **kwargs)  # noqa: E501
        else:
            (data) = self.accounting_transaction_idtransaction_subscriptions_get_with_http_info(id_transaction, **kwargs)  # noqa: E501
            return data

    def accounting_transaction_idtransaction_subscriptions_get_with_http_info(self, id_transaction, **kwargs):  # noqa: E501
        """Récupérer les inscriptions liées à une écriture  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.accounting_transaction_idtransaction_subscriptions_get_with_http_info(id_transaction, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id_transaction: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id_transaction']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method accounting_transaction_idtransaction_subscriptions_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id_transaction' is set
        if ('id_transaction' not in params or
                params['id_transaction'] is None):
            raise ValueError("Missing the required parameter `id_transaction` when calling `accounting_transaction_idtransaction_subscriptions_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_transaction' in params:
            path_params['ID_TRANSACTION'] = params['id_transaction']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/accounting/transaction/{ID_TRANSACTION}/subscriptions', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def accounting_transaction_idtransaction_subscriptions_post(self, subscriptions, id_transaction, **kwargs):  # noqa: E501
        """Associer des inscriptions à une écriture  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.accounting_transaction_idtransaction_subscriptions_post(subscriptions, id_transaction, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[int] subscriptions: (required)
        :param int id_transaction: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.accounting_transaction_idtransaction_subscriptions_post_with_http_info(subscriptions, id_transaction, **kwargs)  # noqa: E501
        else:
            (data) = self.accounting_transaction_idtransaction_subscriptions_post_with_http_info(subscriptions, id_transaction, **kwargs)  # noqa: E501
            return data

    def accounting_transaction_idtransaction_subscriptions_post_with_http_info(self, subscriptions, id_transaction, **kwargs):  # noqa: E501
        """Associer des inscriptions à une écriture  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.accounting_transaction_idtransaction_subscriptions_post_with_http_info(subscriptions, id_transaction, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[int] subscriptions: (required)
        :param int id_transaction: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['subscriptions', 'id_transaction']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method accounting_transaction_idtransaction_subscriptions_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'subscriptions' is set
        if ('subscriptions' not in params or
                params['subscriptions'] is None):
            raise ValueError("Missing the required parameter `subscriptions` when calling `accounting_transaction_idtransaction_subscriptions_post`")  # noqa: E501
        # verify the required parameter 'id_transaction' is set
        if ('id_transaction' not in params or
                params['id_transaction'] is None):
            raise ValueError("Missing the required parameter `id_transaction` when calling `accounting_transaction_idtransaction_subscriptions_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_transaction' in params:
            path_params['ID_TRANSACTION'] = params['id_transaction']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'subscriptions' in params:
            form_params.append(('subscriptions', params['subscriptions']))  # noqa: E501
            collection_formats['subscriptions'] = 'multi'  # noqa: E501

        body_params = None
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/accounting/transaction/{ID_TRANSACTION}/subscriptions', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def accounting_transaction_idtransaction_transactions_delete(self, id_transaction, **kwargs):  # noqa: E501
        """Dissocier des écritures d'une transaction  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.accounting_transaction_idtransaction_transactions_delete(id_transaction, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id_transaction: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.accounting_transaction_idtransaction_transactions_delete_with_http_info(id_transaction, **kwargs)  # noqa: E501
        else:
            (data) = self.accounting_transaction_idtransaction_transactions_delete_with_http_info(id_transaction, **kwargs)  # noqa: E501
            return data

    def accounting_transaction_idtransaction_transactions_delete_with_http_info(self, id_transaction, **kwargs):  # noqa: E501
        """Dissocier des écritures d'une transaction  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.accounting_transaction_idtransaction_transactions_delete_with_http_info(id_transaction, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id_transaction: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id_transaction']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method accounting_transaction_idtransaction_transactions_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id_transaction' is set
        if ('id_transaction' not in params or
                params['id_transaction'] is None):
            raise ValueError("Missing the required parameter `id_transaction` when calling `accounting_transaction_idtransaction_transactions_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_transaction' in params:
            path_params['ID_TRANSACTION'] = params['id_transaction']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/accounting/transaction/{ID_TRANSACTION}/transactions', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def accounting_transaction_idtransaction_transactions_get(self, id_transaction, **kwargs):  # noqa: E501
        """Récupérer les écritures liées à une transaction  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.accounting_transaction_idtransaction_transactions_get(id_transaction, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id_transaction: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.accounting_transaction_idtransaction_transactions_get_with_http_info(id_transaction, **kwargs)  # noqa: E501
        else:
            (data) = self.accounting_transaction_idtransaction_transactions_get_with_http_info(id_transaction, **kwargs)  # noqa: E501
            return data

    def accounting_transaction_idtransaction_transactions_get_with_http_info(self, id_transaction, **kwargs):  # noqa: E501
        """Récupérer les écritures liées à une transaction  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.accounting_transaction_idtransaction_transactions_get_with_http_info(id_transaction, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id_transaction: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id_transaction']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method accounting_transaction_idtransaction_transactions_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id_transaction' is set
        if ('id_transaction' not in params or
                params['id_transaction'] is None):
            raise ValueError("Missing the required parameter `id_transaction` when calling `accounting_transaction_idtransaction_transactions_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_transaction' in params:
            path_params['ID_TRANSACTION'] = params['id_transaction']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/accounting/transaction/{ID_TRANSACTION}/transactions', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def accounting_transaction_idtransaction_transactions_post(self, transactions, id_transaction, **kwargs):  # noqa: E501
        """Associer des écritures à une transaction  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.accounting_transaction_idtransaction_transactions_post(transactions, id_transaction, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[int] transactions: (required)
        :param int id_transaction: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.accounting_transaction_idtransaction_transactions_post_with_http_info(transactions, id_transaction, **kwargs)  # noqa: E501
        else:
            (data) = self.accounting_transaction_idtransaction_transactions_post_with_http_info(transactions, id_transaction, **kwargs)  # noqa: E501
            return data

    def accounting_transaction_idtransaction_transactions_post_with_http_info(self, transactions, id_transaction, **kwargs):  # noqa: E501
        """Associer des écritures à une transaction  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.accounting_transaction_idtransaction_transactions_post_with_http_info(transactions, id_transaction, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[int] transactions: (required)
        :param int id_transaction: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['transactions', 'id_transaction']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method accounting_transaction_idtransaction_transactions_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'transactions' is set
        if ('transactions' not in params or
                params['transactions'] is None):
            raise ValueError("Missing the required parameter `transactions` when calling `accounting_transaction_idtransaction_transactions_post`")  # noqa: E501
        # verify the required parameter 'id_transaction' is set
        if ('id_transaction' not in params or
                params['id_transaction'] is None):
            raise ValueError("Missing the required parameter `id_transaction` when calling `accounting_transaction_idtransaction_transactions_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_transaction' in params:
            path_params['ID_TRANSACTION'] = params['id_transaction']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'transactions' in params:
            form_params.append(('transactions', params['transactions']))  # noqa: E501
            collection_formats['transactions'] = 'multi'  # noqa: E501

        body_params = None
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/accounting/transaction/{ID_TRANSACTION}/transactions', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def accounting_transaction_idtransaction_users_delete(self, id_transaction, **kwargs):  # noqa: E501
        """Dissocier des utilisateurs d'une transaction  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.accounting_transaction_idtransaction_users_delete(id_transaction, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id_transaction: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.accounting_transaction_idtransaction_users_delete_with_http_info(id_transaction, **kwargs)  # noqa: E501
        else:
            (data) = self.accounting_transaction_idtransaction_users_delete_with_http_info(id_transaction, **kwargs)  # noqa: E501
            return data

    def accounting_transaction_idtransaction_users_delete_with_http_info(self, id_transaction, **kwargs):  # noqa: E501
        """Dissocier des utilisateurs d'une transaction  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.accounting_transaction_idtransaction_users_delete_with_http_info(id_transaction, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id_transaction: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id_transaction']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method accounting_transaction_idtransaction_users_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id_transaction' is set
        if ('id_transaction' not in params or
                params['id_transaction'] is None):
            raise ValueError("Missing the required parameter `id_transaction` when calling `accounting_transaction_idtransaction_users_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_transaction' in params:
            path_params['ID_TRANSACTION'] = params['id_transaction']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/accounting/transaction/{ID_TRANSACTION}/users', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def accounting_transaction_idtransaction_users_get(self, id_transaction, **kwargs):  # noqa: E501
        """Lister les utilisateurs liés à une transaction  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.accounting_transaction_idtransaction_users_get(id_transaction, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id_transaction: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.accounting_transaction_idtransaction_users_get_with_http_info(id_transaction, **kwargs)  # noqa: E501
        else:
            (data) = self.accounting_transaction_idtransaction_users_get_with_http_info(id_transaction, **kwargs)  # noqa: E501
            return data

    def accounting_transaction_idtransaction_users_get_with_http_info(self, id_transaction, **kwargs):  # noqa: E501
        """Lister les utilisateurs liés à une transaction  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.accounting_transaction_idtransaction_users_get_with_http_info(id_transaction, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id_transaction: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id_transaction']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method accounting_transaction_idtransaction_users_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id_transaction' is set
        if ('id_transaction' not in params or
                params['id_transaction'] is None):
            raise ValueError("Missing the required parameter `id_transaction` when calling `accounting_transaction_idtransaction_users_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_transaction' in params:
            path_params['ID_TRANSACTION'] = params['id_transaction']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/accounting/transaction/{ID_TRANSACTION}/users', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def accounting_transaction_idtransaction_users_post(self, id_transaction, **kwargs):  # noqa: E501
        """Associer une transaction à des utilisateurs  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.accounting_transaction_idtransaction_users_post(id_transaction, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id_transaction: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.accounting_transaction_idtransaction_users_post_with_http_info(id_transaction, **kwargs)  # noqa: E501
        else:
            (data) = self.accounting_transaction_idtransaction_users_post_with_http_info(id_transaction, **kwargs)  # noqa: E501
            return data

    def accounting_transaction_idtransaction_users_post_with_http_info(self, id_transaction, **kwargs):  # noqa: E501
        """Associer une transaction à des utilisateurs  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.accounting_transaction_idtransaction_users_post_with_http_info(id_transaction, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id_transaction: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id_transaction']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method accounting_transaction_idtransaction_users_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id_transaction' is set
        if ('id_transaction' not in params or
                params['id_transaction'] is None):
            raise ValueError("Missing the required parameter `id_transaction` when calling `accounting_transaction_idtransaction_users_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_transaction' in params:
            path_params['ID_TRANSACTION'] = params['id_transaction']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/accounting/transaction/{ID_TRANSACTION}/users', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def accounting_transaction_post(self, body, **kwargs):  # noqa: E501
        """Créer une transaction comptable  # noqa: E501

        Crée une nouvelle transaction comptable avec les paramètres spécifiés.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.accounting_transaction_post(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AccountingTransactionBody body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.accounting_transaction_post_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.accounting_transaction_post_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def accounting_transaction_post_with_http_info(self, body, **kwargs):  # noqa: E501
        """Créer une transaction comptable  # noqa: E501

        Crée une nouvelle transaction comptable avec les paramètres spécifiés.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.accounting_transaction_post_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AccountingTransactionBody body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method accounting_transaction_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `accounting_transaction_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/accounting/transaction', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def accounting_years_get(self, **kwargs):  # noqa: E501
        """Récupérer les années comptables  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.accounting_years_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.accounting_years_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.accounting_years_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def accounting_years_get_with_http_info(self, **kwargs):  # noqa: E501
        """Récupérer les années comptables  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.accounting_years_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method accounting_years_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/accounting/years', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def accounting_years_idyear_export_formatextension_get(self, id_year, format, extension, **kwargs):  # noqa: E501
        """Exporter un exercice comptable  # noqa: E501

        Exporte l'exercice indiqué. Utiliser 'current' pour l'exercice ouvert en cours.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.accounting_years_idyear_export_formatextension_get(id_year, format, extension, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_year: (required)
        :param str format: (required)
        :param str extension: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.accounting_years_idyear_export_formatextension_get_with_http_info(id_year, format, extension, **kwargs)  # noqa: E501
        else:
            (data) = self.accounting_years_idyear_export_formatextension_get_with_http_info(id_year, format, extension, **kwargs)  # noqa: E501
            return data

    def accounting_years_idyear_export_formatextension_get_with_http_info(self, id_year, format, extension, **kwargs):  # noqa: E501
        """Exporter un exercice comptable  # noqa: E501

        Exporte l'exercice indiqué. Utiliser 'current' pour l'exercice ouvert en cours.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.accounting_years_idyear_export_formatextension_get_with_http_info(id_year, format, extension, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_year: (required)
        :param str format: (required)
        :param str extension: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id_year', 'format', 'extension']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method accounting_years_idyear_export_formatextension_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id_year' is set
        if ('id_year' not in params or
                params['id_year'] is None):
            raise ValueError("Missing the required parameter `id_year` when calling `accounting_years_idyear_export_formatextension_get`")  # noqa: E501
        # verify the required parameter 'format' is set
        if ('format' not in params or
                params['format'] is None):
            raise ValueError("Missing the required parameter `format` when calling `accounting_years_idyear_export_formatextension_get`")  # noqa: E501
        # verify the required parameter 'extension' is set
        if ('extension' not in params or
                params['extension'] is None):
            raise ValueError("Missing the required parameter `extension` when calling `accounting_years_idyear_export_formatextension_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_year' in params:
            path_params['ID_YEAR'] = params['id_year']  # noqa: E501
        if 'format' in params:
            path_params['FORMAT'] = params['format']  # noqa: E501
        if 'extension' in params:
            path_params['EXTENSION'] = params['extension']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/accounting/years/{ID_YEAR}/export/{FORMAT}.{EXTENSION}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def accounting_years_idyear_journal_get(self, id_year, **kwargs):  # noqa: E501
        """Récupérer le journal d'une année comptable  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.accounting_years_idyear_journal_get(id_year, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_year: ID de l'exercice ou 'current' pour l'exercice en cours. (required)
        :param str code:
        :param int id:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.accounting_years_idyear_journal_get_with_http_info(id_year, **kwargs)  # noqa: E501
        else:
            (data) = self.accounting_years_idyear_journal_get_with_http_info(id_year, **kwargs)  # noqa: E501
            return data

    def accounting_years_idyear_journal_get_with_http_info(self, id_year, **kwargs):  # noqa: E501
        """Récupérer le journal d'une année comptable  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.accounting_years_idyear_journal_get_with_http_info(id_year, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id_year: ID de l'exercice ou 'current' pour l'exercice en cours. (required)
        :param str code:
        :param int id:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id_year', 'code', 'id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method accounting_years_idyear_journal_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id_year' is set
        if ('id_year' not in params or
                params['id_year'] is None):
            raise ValueError("Missing the required parameter `id_year` when calling `accounting_years_idyear_journal_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_year' in params:
            path_params['ID_YEAR'] = params['id_year']  # noqa: E501

        query_params = []
        if 'code' in params:
            query_params.append(('code', params['code']))  # noqa: E501
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/accounting/years/{ID_YEAR}/journal', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def download_files_get(self, **kwargs):  # noqa: E501
        """Télécharger tous les fichiers  # noqa: E501

        Télécharge un fichier ZIP contenant tous les fichiers associés (documents, fichiers des écritures, des membres, etc.).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.download_files_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.download_files_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.download_files_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def download_files_get_with_http_info(self, **kwargs):  # noqa: E501
        """Télécharger tous les fichiers  # noqa: E501

        Télécharge un fichier ZIP contenant tous les fichiers associés (documents, fichiers des écritures, des membres, etc.).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.download_files_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method download_files_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/download/files', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def download_get(self, **kwargs):  # noqa: E501
        """Télécharger la base de données  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.download_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.download_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.download_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def download_get_with_http_info(self, **kwargs):  # noqa: E501
        """Télécharger la base de données  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.download_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method download_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/download', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def errors_log_get(self, **kwargs):  # noqa: E501
        """Récupérer le log d'erreurs système  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.errors_log_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.errors_log_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.errors_log_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def errors_log_get_with_http_info(self, **kwargs):  # noqa: E501
        """Récupérer le log d'erreurs système  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.errors_log_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method errors_log_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/errors/log', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def errors_report_post(self, **kwargs):  # noqa: E501
        """Envoyer un rapport d'erreur  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.errors_report_post(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.errors_report_post_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.errors_report_post_with_http_info(**kwargs)  # noqa: E501
            return data

    def errors_report_post_with_http_info(self, **kwargs):  # noqa: E501
        """Envoyer un rapport d'erreur  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.errors_report_post_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method errors_report_post" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/errors/report', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def services_subscriptions_import_put(self, file, **kwargs):  # noqa: E501
        """Importer les inscriptions des membres aux activités  # noqa: E501

        Permet d'importer un fichier CSV des inscriptions des membres aux activités.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.services_subscriptions_import_put(file, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str file: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.services_subscriptions_import_put_with_http_info(file, **kwargs)  # noqa: E501
        else:
            (data) = self.services_subscriptions_import_put_with_http_info(file, **kwargs)  # noqa: E501
            return data

    def services_subscriptions_import_put_with_http_info(self, file, **kwargs):  # noqa: E501
        """Importer les inscriptions des membres aux activités  # noqa: E501

        Permet d'importer un fichier CSV des inscriptions des membres aux activités.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.services_subscriptions_import_put_with_http_info(file, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str file: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['file']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method services_subscriptions_import_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'file' is set
        if ('file' not in params or
                params['file'] is None):
            raise ValueError("Missing the required parameter `file` when calling `services_subscriptions_import_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'file' in params:
            local_var_files['file'] = params['file']  # noqa: E501

        body_params = None
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/services/subscriptions/import', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def sql_post(self, sql, format, **kwargs):  # noqa: E501
        """Exécuter une requête SQL SELECT  # noqa: E501

        Permet d'exécuter une requête SQL SELECT sur la base de données (aucune requête d'écriture n'est autorisée).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.sql_post(sql, format, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str sql: (required)
        :param str format: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.sql_post_with_http_info(sql, format, **kwargs)  # noqa: E501
        else:
            (data) = self.sql_post_with_http_info(sql, format, **kwargs)  # noqa: E501
            return data

    def sql_post_with_http_info(self, sql, format, **kwargs):  # noqa: E501
        """Exécuter une requête SQL SELECT  # noqa: E501

        Permet d'exécuter une requête SQL SELECT sur la base de données (aucune requête d'écriture n'est autorisée).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.sql_post_with_http_info(sql, format, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str sql: (required)
        :param str format: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['sql', 'format']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method sql_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'sql' is set
        if ('sql' not in params or
                params['sql'] is None):
            raise ValueError("Missing the required parameter `sql` when calling `sql_post`")  # noqa: E501
        # verify the required parameter 'format' is set
        if ('format' not in params or
                params['format'] is None):
            raise ValueError("Missing the required parameter `format` when calling `sql_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'sql' in params:
            form_params.append(('sql', params['sql']))  # noqa: E501
        if 'format' in params:
            form_params.append(('format', params['format']))  # noqa: E501

        body_params = None
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/sql', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def user_categories_get(self, **kwargs):  # noqa: E501
        """Récupérer la liste des catégories de membres  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.user_categories_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.user_categories_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.user_categories_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def user_categories_get_with_http_info(self, **kwargs):  # noqa: E501
        """Récupérer la liste des catégories de membres  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.user_categories_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method user_categories_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/user/categories', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def user_category_idformat_get(self, id, format, **kwargs):  # noqa: E501
        """Exporter les membres d'une catégorie  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.user_category_idformat_get(id, format, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str format: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.user_category_idformat_get_with_http_info(id, format, **kwargs)  # noqa: E501
        else:
            (data) = self.user_category_idformat_get_with_http_info(id, format, **kwargs)  # noqa: E501
            return data

    def user_category_idformat_get_with_http_info(self, id, format, **kwargs):  # noqa: E501
        """Exporter les membres d'une catégorie  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.user_category_idformat_get_with_http_info(id, format, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str format: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'format']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method user_category_idformat_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `user_category_idformat_get`")  # noqa: E501
        # verify the required parameter 'format' is set
        if ('format' not in params or
                params['format'] is None):
            raise ValueError("Missing the required parameter `format` when calling `user_category_idformat_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['ID'] = params['id']  # noqa: E501
        if 'format' in params:
            path_params['FORMAT'] = params['format']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/user/category/{ID}.{FORMAT}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def user_iduser_delete(self, id_user, **kwargs):  # noqa: E501
        """Supprimer un utilisateur  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.user_iduser_delete(id_user, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id_user: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.user_iduser_delete_with_http_info(id_user, **kwargs)  # noqa: E501
        else:
            (data) = self.user_iduser_delete_with_http_info(id_user, **kwargs)  # noqa: E501
            return data

    def user_iduser_delete_with_http_info(self, id_user, **kwargs):  # noqa: E501
        """Supprimer un utilisateur  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.user_iduser_delete_with_http_info(id_user, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id_user: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id_user']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method user_iduser_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id_user' is set
        if ('id_user' not in params or
                params['id_user'] is None):
            raise ValueError("Missing the required parameter `id_user` when calling `user_iduser_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_user' in params:
            path_params['ID_USER'] = params['id_user']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/user/{ID_USER}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def user_iduser_get(self, id_user, **kwargs):  # noqa: E501
        """Récupérer un utilisateur  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.user_iduser_get(id_user, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id_user: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.user_iduser_get_with_http_info(id_user, **kwargs)  # noqa: E501
        else:
            (data) = self.user_iduser_get_with_http_info(id_user, **kwargs)  # noqa: E501
            return data

    def user_iduser_get_with_http_info(self, id_user, **kwargs):  # noqa: E501
        """Récupérer un utilisateur  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.user_iduser_get_with_http_info(id_user, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id_user: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id_user']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method user_iduser_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id_user' is set
        if ('id_user' not in params or
                params['id_user'] is None):
            raise ValueError("Missing the required parameter `id_user` when calling `user_iduser_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_user' in params:
            path_params['ID_USER'] = params['id_user']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/user/{ID_USER}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def user_iduser_post(self, id_user, **kwargs):  # noqa: E501
        """Mettre à jour un utilisateur  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.user_iduser_post(id_user, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id_user: (required)
        :param str nom:
        :param str prenom:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.user_iduser_post_with_http_info(id_user, **kwargs)  # noqa: E501
        else:
            (data) = self.user_iduser_post_with_http_info(id_user, **kwargs)  # noqa: E501
            return data

    def user_iduser_post_with_http_info(self, id_user, **kwargs):  # noqa: E501
        """Mettre à jour un utilisateur  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.user_iduser_post_with_http_info(id_user, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id_user: (required)
        :param str nom:
        :param str prenom:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id_user', 'nom', 'prenom']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method user_iduser_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id_user' is set
        if ('id_user' not in params or
                params['id_user'] is None):
            raise ValueError("Missing the required parameter `id_user` when calling `user_iduser_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_user' in params:
            path_params['ID_USER'] = params['id_user']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'nom' in params:
            form_params.append(('nom', params['nom']))  # noqa: E501
        if 'prenom' in params:
            form_params.append(('prenom', params['prenom']))  # noqa: E501

        body_params = None
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/user/{ID_USER}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def user_iduser_put(self, id_user, **kwargs):  # noqa: E501
        """Mettre à jour un utilisateur  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.user_iduser_put(id_user, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id_user: (required)
        :param str email:
        :param int id_category:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.user_iduser_put_with_http_info(id_user, **kwargs)  # noqa: E501
        else:
            (data) = self.user_iduser_put_with_http_info(id_user, **kwargs)  # noqa: E501
            return data

    def user_iduser_put_with_http_info(self, id_user, **kwargs):  # noqa: E501
        """Mettre à jour un utilisateur  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.user_iduser_put_with_http_info(id_user, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id_user: (required)
        :param str email:
        :param int id_category:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id_user', 'email', 'id_category']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method user_iduser_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id_user' is set
        if ('id_user' not in params or
                params['id_user'] is None):
            raise ValueError("Missing the required parameter `id_user` when calling `user_iduser_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_user' in params:
            path_params['ID_USER'] = params['id_user']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'email' in params:
            form_params.append(('email', params['email']))  # noqa: E501
        if 'id_category' in params:
            form_params.append(('id_category', params['id_category']))  # noqa: E501

        body_params = None
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/user/{ID_USER}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def user_import_preview_post(self, file, **kwargs):  # noqa: E501
        """Prévisualiser un import de membres (POST)  # noqa: E501

        Identique à PUT, mais avec paramètres dans le corps.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.user_import_preview_post(file, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str file: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.user_import_preview_post_with_http_info(file, **kwargs)  # noqa: E501
        else:
            (data) = self.user_import_preview_post_with_http_info(file, **kwargs)  # noqa: E501
            return data

    def user_import_preview_post_with_http_info(self, file, **kwargs):  # noqa: E501
        """Prévisualiser un import de membres (POST)  # noqa: E501

        Identique à PUT, mais avec paramètres dans le corps.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.user_import_preview_post_with_http_info(file, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str file: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['file']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method user_import_preview_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'file' is set
        if ('file' not in params or
                params['file'] is None):
            raise ValueError("Missing the required parameter `file` when calling `user_import_preview_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'file' in params:
            local_var_files['file'] = params['file']  # noqa: E501

        body_params = None
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/user/import/preview', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def user_import_preview_put(self, file, **kwargs):  # noqa: E501
        """Prévisualiser un import de membres  # noqa: E501

        Permet de simuler un import et d'afficher les erreurs ou modifications avant l'importation réelle.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.user_import_preview_put(file, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str file: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.user_import_preview_put_with_http_info(file, **kwargs)  # noqa: E501
        else:
            (data) = self.user_import_preview_put_with_http_info(file, **kwargs)  # noqa: E501
            return data

    def user_import_preview_put_with_http_info(self, file, **kwargs):  # noqa: E501
        """Prévisualiser un import de membres  # noqa: E501

        Permet de simuler un import et d'afficher les erreurs ou modifications avant l'importation réelle.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.user_import_preview_put_with_http_info(file, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str file: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['file']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method user_import_preview_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'file' is set
        if ('file' not in params or
                params['file'] is None):
            raise ValueError("Missing the required parameter `file` when calling `user_import_preview_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'file' in params:
            local_var_files['file'] = params['file']  # noqa: E501

        body_params = None
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/user/import/preview', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def user_import_put(self, file, **kwargs):  # noqa: E501
        """Importer une liste de membres  # noqa: E501

        Permet d'importer un fichier CSV/XLSX/ODS de la liste des membres.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.user_import_put(file, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str file: (required)
        :param str mode:
        :param int skip_lines: Nombre de lignes à ignorer
        :param str column_0: Correspondance de la colonne 0
        :param str column_1: Correspondance de la colonne 1
        :param str column_2: Correspondance de la colonne 2
        :param str column_3: Correspondance de la colonne 3
        :param str column_4: Correspondance de la colonne 4
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.user_import_put_with_http_info(file, **kwargs)  # noqa: E501
        else:
            (data) = self.user_import_put_with_http_info(file, **kwargs)  # noqa: E501
            return data

    def user_import_put_with_http_info(self, file, **kwargs):  # noqa: E501
        """Importer une liste de membres  # noqa: E501

        Permet d'importer un fichier CSV/XLSX/ODS de la liste des membres.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.user_import_put_with_http_info(file, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str file: (required)
        :param str mode:
        :param int skip_lines: Nombre de lignes à ignorer
        :param str column_0: Correspondance de la colonne 0
        :param str column_1: Correspondance de la colonne 1
        :param str column_2: Correspondance de la colonne 2
        :param str column_3: Correspondance de la colonne 3
        :param str column_4: Correspondance de la colonne 4
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['file', 'mode', 'skip_lines', 'column_0', 'column_1', 'column_2', 'column_3', 'column_4']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method user_import_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'file' is set
        if ('file' not in params or
                params['file'] is None):
            raise ValueError("Missing the required parameter `file` when calling `user_import_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'mode' in params:
            query_params.append(('mode', params['mode']))  # noqa: E501
        if 'skip_lines' in params:
            query_params.append(('skip_lines', params['skip_lines']))  # noqa: E501
        if 'column_0' in params:
            query_params.append(('column[0]', params['column_0']))  # noqa: E501
        if 'column_1' in params:
            query_params.append(('column[1]', params['column_1']))  # noqa: E501
        if 'column_2' in params:
            query_params.append(('column[2]', params['column_2']))  # noqa: E501
        if 'column_3' in params:
            query_params.append(('column[3]', params['column_3']))  # noqa: E501
        if 'column_4' in params:
            query_params.append(('column[4]', params['column_4']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'file' in params:
            local_var_files['file'] = params['file']  # noqa: E501

        body_params = None
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/user/import', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def user_new_post(self, nom, prenom, email, id_category, password, **kwargs):  # noqa: E501
        """Créer un nouveau membre  # noqa: E501

        Ajoute un nouvel utilisateur à l'association.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.user_new_post(nom, prenom, email, id_category, password, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str nom: (required)
        :param str prenom: (required)
        :param str email: (required)
        :param int id_category: (required)
        :param str password: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.user_new_post_with_http_info(nom, prenom, email, id_category, password, **kwargs)  # noqa: E501
        else:
            (data) = self.user_new_post_with_http_info(nom, prenom, email, id_category, password, **kwargs)  # noqa: E501
            return data

    def user_new_post_with_http_info(self, nom, prenom, email, id_category, password, **kwargs):  # noqa: E501
        """Créer un nouveau membre  # noqa: E501

        Ajoute un nouvel utilisateur à l'association.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.user_new_post_with_http_info(nom, prenom, email, id_category, password, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str nom: (required)
        :param str prenom: (required)
        :param str email: (required)
        :param int id_category: (required)
        :param str password: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['nom', 'prenom', 'email', 'id_category', 'password']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method user_new_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'nom' is set
        if ('nom' not in params or
                params['nom'] is None):
            raise ValueError("Missing the required parameter `nom` when calling `user_new_post`")  # noqa: E501
        # verify the required parameter 'prenom' is set
        if ('prenom' not in params or
                params['prenom'] is None):
            raise ValueError("Missing the required parameter `prenom` when calling `user_new_post`")  # noqa: E501
        # verify the required parameter 'email' is set
        if ('email' not in params or
                params['email'] is None):
            raise ValueError("Missing the required parameter `email` when calling `user_new_post`")  # noqa: E501
        # verify the required parameter 'id_category' is set
        if ('id_category' not in params or
                params['id_category'] is None):
            raise ValueError("Missing the required parameter `id_category` when calling `user_new_post`")  # noqa: E501
        # verify the required parameter 'password' is set
        if ('password' not in params or
                params['password'] is None):
            raise ValueError("Missing the required parameter `password` when calling `user_new_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'nom' in params:
            form_params.append(('nom', params['nom']))  # noqa: E501
        if 'prenom' in params:
            form_params.append(('prenom', params['prenom']))  # noqa: E501
        if 'email' in params:
            form_params.append(('email', params['email']))  # noqa: E501
        if 'id_category' in params:
            form_params.append(('id_category', params['id_category']))  # noqa: E501
        if 'password' in params:
            form_params.append(('password', params['password']))  # noqa: E501

        body_params = None
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/user/new', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def web_attachment_pageurifilename_get(self, page_uri, filename, **kwargs):  # noqa: E501
        """Récupérer un fichier joint d'une page  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.web_attachment_pageurifilename_get(page_uri, filename, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str page_uri: (required)
        :param str filename: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.web_attachment_pageurifilename_get_with_http_info(page_uri, filename, **kwargs)  # noqa: E501
        else:
            (data) = self.web_attachment_pageurifilename_get_with_http_info(page_uri, filename, **kwargs)  # noqa: E501
            return data

    def web_attachment_pageurifilename_get_with_http_info(self, page_uri, filename, **kwargs):  # noqa: E501
        """Récupérer un fichier joint d'une page  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.web_attachment_pageurifilename_get_with_http_info(page_uri, filename, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str page_uri: (required)
        :param str filename: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page_uri', 'filename']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method web_attachment_pageurifilename_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'page_uri' is set
        if ('page_uri' not in params or
                params['page_uri'] is None):
            raise ValueError("Missing the required parameter `page_uri` when calling `web_attachment_pageurifilename_get`")  # noqa: E501
        # verify the required parameter 'filename' is set
        if ('filename' not in params or
                params['filename'] is None):
            raise ValueError("Missing the required parameter `filename` when calling `web_attachment_pageurifilename_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'page_uri' in params:
            path_params['PAGE_URI'] = params['page_uri']  # noqa: E501
        if 'filename' in params:
            path_params['FILENAME'] = params['filename']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/web/attachment/{PAGE_URI}/{FILENAME}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def web_html_pageuri_get(self, page_uri, **kwargs):  # noqa: E501
        """Récupérer le contenu HTML d'une page  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.web_html_pageuri_get(page_uri, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str page_uri: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.web_html_pageuri_get_with_http_info(page_uri, **kwargs)  # noqa: E501
        else:
            (data) = self.web_html_pageuri_get_with_http_info(page_uri, **kwargs)  # noqa: E501
            return data

    def web_html_pageuri_get_with_http_info(self, page_uri, **kwargs):  # noqa: E501
        """Récupérer le contenu HTML d'une page  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.web_html_pageuri_get_with_http_info(page_uri, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str page_uri: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page_uri']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method web_html_pageuri_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'page_uri' is set
        if ('page_uri' not in params or
                params['page_uri'] is None):
            raise ValueError("Missing the required parameter `page_uri` when calling `web_html_pageuri_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'page_uri' in params:
            path_params['PAGE_URI'] = params['page_uri']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/web/html/{PAGE_URI}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def web_list_get(self, **kwargs):  # noqa: E501
        """Lister les pages du site web  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.web_list_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.web_list_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.web_list_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def web_list_get_with_http_info(self, **kwargs):  # noqa: E501
        """Lister les pages du site web  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.web_list_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method web_list_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/web/list', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def web_page_pageuri_get(self, page_uri, **kwargs):  # noqa: E501
        """Récupérer les informations d'une page  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.web_page_pageuri_get(page_uri, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str page_uri: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.web_page_pageuri_get_with_http_info(page_uri, **kwargs)  # noqa: E501
        else:
            (data) = self.web_page_pageuri_get_with_http_info(page_uri, **kwargs)  # noqa: E501
            return data

    def web_page_pageuri_get_with_http_info(self, page_uri, **kwargs):  # noqa: E501
        """Récupérer les informations d'une page  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.web_page_pageuri_get_with_http_info(page_uri, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str page_uri: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page_uri']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method web_page_pageuri_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'page_uri' is set
        if ('page_uri' not in params or
                params['page_uri'] is None):
            raise ValueError("Missing the required parameter `page_uri` when calling `web_page_pageuri_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'page_uri' in params:
            path_params['PAGE_URI'] = params['page_uri']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/web/page/{PAGE_URI}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
